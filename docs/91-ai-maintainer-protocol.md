# 91 — AI 维护协议（给未来维护这个仓库的智能体）

> 你是一个维护者智能体。你的目标不是“写更多”，而是让本仓库长期保持：**可增量学习、可检索、可执行、无敏感信息泄露**。

---

## 91.1 维护者的输入/输出契约

### 你会接到的输入（常见）
- “我学会了一个新技能/工具/套路，把它加进仓库”
- “某个章节过时了，更新一下”
- “分身回答不稳定，手册需要更清晰的路由/示例”

### 你必须交付的输出
- 修改后的文件（docs / README / SUMMARY / CHANGELOG 等）
- 一条可读的更新记录（CHANGELOG）
- 一次干净的 commit（信息明确）

---

## 91.2 决策流程（非常重要，按顺序执行）

### Step 0：安全扫描（强制）
在你写任何内容前，先检查变更是否可能引入敏感信息：
- token / PAT / cookie / credentials
- 私人链接（带鉴权参数）
- 真实用户隐私信息

如果有风险：
- 用占位符替换（如 `<GITHUB_TOKEN>`、`<USER_ID>`）
- 或者把内容改写成“方法论”，不要写具体值

### Step 1：分类（决定落点）
把新增内容归类到一个模块：
- 原则/边界/风格 → `docs/00-principles.md`
- 工作流/交付物 → `docs/01-workflow.md`
- 文件/本地执行 → `docs/02-tools-core.md`
- 网页证据链 → `docs/03-web.md`
- 外包/子代理 → `docs/04-sessions-outsourcing.md`
- cron/message → `docs/05-scheduling-and-messaging.md`
- Feishu → `docs/06-feishu.md`
- token/成本审计 → `docs/07-token-audit.md`
- 维护流程/规范 → `docs/90-maintenance.md` / `CONTRIBUTING.md`

若无法归类，再创建新模块，但要先问自己：是否只是某模块的子标题？

### Step 2：用“可执行条目模板”写入
每个条目至少包含（缺一不可）：
- 适用场景
- 工具选择（优先级/理由）
- 步骤（可复现）
- 边界/风险（何时必须先确认）

加分项：最小示例 + 验证方法。

### Step 3：路由与入口同步（协调性）
- 如果新增内容会影响“分身遇到某任务该读哪里”：更新 `SUMMARY.md`
- 如果新增了新模块/新入口：更新 `README.md`（目录索引）

### Step 4：增量学习保证（CHANGELOG 必须）
在 `CHANGELOG.md` 追加 1~3 行，让分身能只看 changelog 就知道新增了什么、该去哪读。

### Step 5：提交（commit）
- commit message 用 Conventional Commits（推荐）：`docs:` / `fix:` / `feat:`
- 一次提交尽量只做一类改动（便于回滚与审查）

---

## 91.3 质量门槛（写完后自检）

在提交前，逐条回答：
1) 分身能否在 30 秒内从 README/SUMMARY 找到该新增内容？
2) 分身是否能按文档步骤复现？（是否缺关键参数说明？）
3) 是否写清楚“不要做什么/什么时候必须先确认”？
4) CHANGELOG 是否写了“新增了什么 + 去哪读”？
5) 是否包含任何敏感信息？（必须为“否”）

---

## 91.4 常见失败模式（避免）
- 只写概念、不写步骤（分身无法执行）
- 写了步骤但没写边界（容易误用）
- 改了 docs 但没改 SUMMARY/README（分身找不到）
- 写进了 token/PAT/私人链接（公开仓库事故）

